/*! For license information please see 662.js.LICENSE.txt */
"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[662],{4061:(t,e,o)=>{var s=o(43842);function n(t,e,o){var n,r,d,l;e=e||1;for(var h=0;h<t[0].length;h++){var c=t[0][h];(!h||c[0]<n)&&(n=c[0]),(!h||c[1]<r)&&(r=c[1]),(!h||c[0]>d)&&(d=c[0]),(!h||c[1]>l)&&(l=c[1])}var u=d-n,g=l-r,p=Math.min(u,g),f=p/2;if(0===p){var w=[n,r];return w.distance=0,w}for(var m=new s(void 0,a),_=n;_<d;_+=p)for(var v=r;v<l;v+=p)m.push(new i(_+f,v+f,f,t));var b=function(t){for(var e=0,o=0,s=0,n=t[0],a=0,r=n.length,d=r-1;a<r;d=a++){var l=n[a],h=n[d],c=l[0]*h[1]-h[0]*l[1];o+=(l[0]+h[0])*c,s+=(l[1]+h[1])*c,e+=3*c}return 0===e?new i(n[0][0],n[0][1],0,t):new i(o/e,s/e,0,t)}(t),W=new i(n+u/2,r+g/2,0,t);W.d>b.d&&(b=W);for(var I=m.length;m.length;){var N=m.pop();N.d>b.d&&(b=N,o&&console.log("found best %d after %d probes",Math.round(1e4*N.d)/1e4,I)),N.max-b.d<=e||(f=N.h/2,m.push(new i(N.x-f,N.y-f,f,t)),m.push(new i(N.x+f,N.y-f,f,t)),m.push(new i(N.x-f,N.y+f,f,t)),m.push(new i(N.x+f,N.y+f,f,t)),I+=4)}o&&(console.log("num probes: "+I),console.log("best distance: "+b.d));var x=[b.x,b.y];return x.distance=b.d,x}function a(t,e){return e.max-t.max}function i(t,e,o,s){this.x=t,this.y=e,this.h=o,this.d=function(t,e,o){for(var s=!1,n=1/0,a=0;a<o.length;a++)for(var i=o[a],d=0,l=i.length,h=l-1;d<l;h=d++){var c=i[d],u=i[h];c[1]>e!=u[1]>e&&t<(u[0]-c[0])*(e-c[1])/(u[1]-c[1])+c[0]&&(s=!s),n=Math.min(n,r(t,e,c,u))}return 0===n?0:(s?1:-1)*Math.sqrt(n)}(t,e,s),this.max=this.d+this.h*Math.SQRT2}function r(t,e,o,s){var n=o[0],a=o[1],i=s[0]-n,r=s[1]-a;if(0!==i||0!==r){var d=((t-n)*i+(e-a)*r)/(i*i+r*r);d>1?(n=s[0],a=s[1]):d>0&&(n+=i*d,a+=r*d)}return(i=t-n)*i+(r=e-a)*r}s.default&&(s=s.default),t.exports=n,t.exports.default=n},43842:(t,e,o)=>{o.r(e),o.d(e,{default:()=>s});class s{constructor(t=[],e=n){if(this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:o}=this,s=e[t];for(;t>0;){const n=t-1>>1,a=e[n];if(o(s,a)>=0)break;e[t]=a,t=n}e[t]=s}_down(t){const{data:e,compare:o}=this,s=this.length>>1,n=e[t];for(;t<s;){let s=1+(t<<1),a=e[s];const i=s+1;if(i<this.length&&o(e[i],a)<0&&(s=i,a=e[i]),o(a,n)>=0)break;e[t]=a,t=s}e[t]=n}}function n(t,e){return t<e?-1:t>e?1:0}},42605:(t,e,o)=>{o.r(e),o.d(e,{default:()=>et});var s=o(97542),n=o(89570),a=o(35221),i=o(5823),r=o(80742),d=o(63422),l=o(38399),h=o(71166),c=o(56163),u=o(76957);class g extends c.K{constructor(t,e,o,s){super(t,e),this.room=o,this.id=this.room.id,this.title=this.room.getRoomLabel(),this.icon="icon-edit-floorplan",this.typeId=i.SF.MODELROOM,this.layerId=d.gi,this.dateBucket=a.Z.OLDER,this.enabled=!0,this.floorId=s}}var p=o(81396),f=o(46391),w=o(78283),m=o(4061),_=o.n(m);class v{constructor(t,e,o,s,n="Unknown",a=!0){this.id=t,this.name=e,this.points=o,this.walls=s,this.roomType=n,this.useRoomTypeAsName=a}get floorIndex(){return this.points[0].floorIndex}getSnapshot(){return{height:0,lowerElevation:0,source:"frontend",vertices:this.points.map((t=>t.id))}}getViewCenter(){const t=this.points.map((t=>[t.x,t.z]));t.push([this.points[0].x,this.points[0].z]);const e=_()([t],.1);return new p.Vector3(e[0],0,e[1])}getAreaText(t){let e=this.area;t===f.M.IMPERIAL&&(e=(0,w.Nv)(e));const o=t===f.M.IMPERIAL?" sq ft":" sq m";return Math.round(e)+o}getRoomLabel(){return this.useRoomTypeAsName?this.roomType:this.name}}var b=o(92558);class W{constructor(t,e,o,s,n){this.bias=.5,this.openings=[],this._t1=new p.Vector3,this._t2=new p.Vector3,this.id=t,this.from=e,this.to=o,this.width=s,this.bias=n}static getCompositeKey(t,e){const o=[t,e].sort();return`${o[0]}:${o[1]}`}get floorIndex(){return this.from.floorIndex}getOtherNode(t){if(t===this.from)return this.to;if(t===this.to)return this.from;throw new Error("WallNode does not belong to edge.")}hasNodes(t,e){const{from:o,to:s}=this;return!(t!==o&&t!==s||e!==o&&e!==s)}getBiasAdjustmentVec(t=new p.Vector3){this.getNormal(t);const e=(this.bias-.5)*-this.width;return t.multiplyScalar(e),t}getNormal(t=new p.Vector3){return this.getDirection(t),t.normalize(),t.set(-t.z,0,t.x),t}getDirection(t){const e=t||new p.Vector3;return e.set(this.to.x-this.from.x,0,this.to.z-this.from.z),e}getLine3(t){const e=t||new p.Line3;return this.from.getVec3(e.start),this.to.getVec3(e.end),e}getProjection(t){const e=this._t1.copy(t).sub(this.from.getVec3(this._t2)),o=this.getDirection(this._t2);return e.dot(o)/o.length()}getSnapshot(){const t={thickness:this.width};if(this.openings.length){const e={};for(const t of this.openings)e[t.id]=t.getSnapshot();t.openings=e}return t}getViewCenter(){return(new p.Vector3).addVectors(this.to.getVec3(),this.from.getVec3()).multiplyScalar(.5)}get length(){const t=this.from.x-this.to.x,e=this.from.z-this.to.z;return Math.sqrt(t*t+e*e)}clone(){const t=new W(this.id,this.from,this.to,this.width,this.bias);return t.openings.push(...this.openings),t}}class I{constructor(t,e,o,s){this.id=t,this.floorIndex=e,this.x=o,this.z=s}getPoint(){return{x:this.x,z:this.z}}getVec3(t){const e=t||new p.Vector3;return e.set(this.x,0,this.z),e}getViewCenter(){return this.getVec3()}getSnapshot(){return{x:this.x,y:-this.z}}}var N=o(83021);class x{constructor(t){this.afterAction=t,this.actions=[]}run(){for(const t of this.actions)t.run(),this.afterAction()}invert(){for(let t=this.actions.length-1;t>=0;t--){this.actions[t].invert(),this.afterAction()}}merge(t){if(0===this.actions.length)this.actions.push(t);else{const e=this.actions[this.actions.length-1];e&&e.merge(t)||this.actions.push(t)}return!0}}class y{constructor(t){this.afterAction=t,this.undoBuffer=new N.P(50),this.finalized=!1}push(t){(this.undoBuffer.isEmpty()||this.finalized)&&(this.undoBuffer.push(new x(this.afterAction)),this.finalized=!1);const e=this.undoBuffer.peek();e&&e.merge(t)}pop(){return this.undoBuffer.pop()}finalize(){this.finalized=!0}availableUndos(){return this.undoBuffer.count}}var O,R=o(35895),P=o(97998);function C(t,e=!1){let o=0;for(let e=0,s=t.length;e<s;e++){const n=t[e],a=t[e===s-1?0:e+1];o+=n[0]*a[1],o-=a[0]*n[1]}return e?o/2:Math.abs(o/2)}function z(t){const e=t.map((t=>[t.x,t.z]));return e.push(e[0]),C(e)}!function(t){t.DOOR="door",t.OPENING="opening"}(O||(O={}));class E{constructor(t,e,o,s,n){this.id=t,this.wallId=e,this.type=o,this.relativePos=s,this.width=n}get floorIndex(){return-1}getViewCenter(){return new p.Vector3(0,0,0)}getSnapshot(){const{type:t,relativePos:e,width:o}=this;return{lowerElevation:0,height:0,type:t,relativePos:e,width:o}}}class T{constructor(){this.data=new Map,this.addedObservers=new Set,this.updatedObservers=new Set,this.deletedObservers=new Set}clear(){this.data.clear()}get(t){return this.data.get(t)}set(t,e){this.data.set(t,e)}delete(t){this.data.delete(t)}has(t){return this.data.has(t)}onChanged(t){return(0,R.k1)((()=>{t.onAdded&&this.addedObservers.add(t.onAdded),t.onUpdated&&this.updatedObservers.add(t.onUpdated),t.onRemoved&&this.deletedObservers.add(t.onRemoved)}),(()=>{t.onAdded&&this.addedObservers.delete(t.onAdded),t.onUpdated&&this.updatedObservers.delete(t.onUpdated),t.onRemoved&&this.deletedObservers.delete(t.onRemoved)}),!0)}}class A{constructor(t,e){this.data=t,this.inputs=e,this._outputCache=null}onRun(t){throw new Error("Method not implemented.")}onInvert(t,e){throw new Error("Method not implemented.")}run(){this._outputCache=this.onRun(this.inputs)}invert(){if(!this._outputCache)throw new Error("Attempted to inverse a data action before running it");this.onInvert(this._outputCache,this.inputs),this._outputCache=null}merge(t){return!1}get output(){if(this._outputCache)return this._outputCache;throw new Error("Tried to read output of an action before it was run")}}class F extends A{onRun(t){const e=this.data.getNode(t.nodeId),o={x:e.x,z:e.z};return this.data._updateNode(t.nodeId,t.newPos),this.data._updateWallForNodes(e),{prevPos:o}}onInvert(t,e){this.data._updateNode(e.nodeId,t.prevPos);const o=this.data.getNode(e.nodeId);this.data._updateWallForNodes(o)}merge(t){return t instanceof F&&t.inputs.nodeId===this.inputs.nodeId&&(this.inputs.newPos=t.inputs.newPos,!0)}}class M extends A{onRun(t){const e=this.data._createNode(t.from,t.floorIndex),o=this.data._createNode(t.to,t.floorIndex),s=this.data._createWall(e,o,t.width,[],.5);return{fromId:e.id,toId:o.id,wall:s.id}}onInvert(t,e){this.data._deleteWall(t.wall),this.data._deleteNode(t.fromId),this.data._deleteNode(t.toId)}merge(t){return!!(t instanceof F&&this._outputCache&&t.inputs.nodeId===this._outputCache.toId)&&(this.inputs.to=t.inputs.newPos,!0)}}class V extends A{onRun(t){const e=this.data.getWall(t.wallId),o=e.from.getPoint(),s=e.to.getPoint();return this.data._updateNode(e.from.id,t.newFromPos),this.data._updateNode(e.to.id,t.newToPos),this.data._updateWallForNodes(e.from,e.to),{prevFromPos:o,prevToPos:s}}onInvert(t,e){const o=this.data.getWall(e.wallId);this.data._updateNode(o.from.id,t.prevFromPos),this.data._updateNode(o.to.id,t.prevToPos),this.data._updateWallForNodes(o.from,o.to)}merge(t){return t instanceof V&&t.inputs.wallId===this.inputs.wallId&&(this.inputs.newFromPos=t.inputs.newFromPos,this.inputs.newToPos=t.inputs.newToPos,!0)}}class S extends A{onRun(t){const e=this.data.getNode(t.fromId),o=this.data._createNode(t.to,e.floorIndex),s=this.data._createWall(e,o,t.width,[],.5);return{toId:o.id,wall:s.id}}onInvert(t,e){this.data._deleteWall(t.wall),this.data._deleteNode(t.toId)}merge(t){return!!(t instanceof F&&this._outputCache&&t.inputs.nodeId===this._outputCache.toId)&&(this.inputs.to=t.inputs.newPos,!0)}}function B(t,e,o){const s=new p.Line3(t.from.getVec3(),t.to.getVec3()),n=e.map((t=>({wall:t,line:new p.Line3(t.from.getVec3(),t.to.getVec3())}))),a=(t,e)=>{const o=t.closestPointToPointParameter(e,!1);if(!(o<0||o>1))return o};for(const e of t.openings){const{type:t,width:i,relativePos:r,id:d}=e,l=s.at(r,new p.Vector3);for(const{wall:e,line:s}of n){const n=a(s,l);if(void 0!==n){o._createWallOpening(e,t,n,i,d);break}}}}class D extends A{onRun(t){const e=this.data.getNode(t.mergeId),o=this.data.getNode(t.keepId),s=o.getPoint();this.data._updateNode(o.id,e.getPoint());const n=this.data.getWallsForNode(e),a=[];for(const t of n){const s=t.clone(),n=t.getOtherNode(e),i=t.width;this.data._deleteWall(t.id);let r=null;this.needsReplacementWall(t,e,o)&&(r=this.data._createWall(n,o,i,[],t.bias),B(t,[r],this.data)),a.push({deleted:s,created:r})}return this.data._deleteNode(e.id),this.data._updateWallForNodes(e,o),{deletedNode:e,wallDiff:a,oldKeepNodePos:s}}onInvert(t,e){const o=t.deletedNode,s=this.data._createNode(o.getPoint(),o.floorIndex,o.id);for(const e of t.wallDiff)e.created&&this.data._deleteWall(e.created.id),this.data._createWall(s,e.deleted.getOtherNode(t.deletedNode),e.deleted.width,e.deleted.openings,e.deleted.bias);this.data._updateNode(e.keepId,t.oldKeepNodePos),this.data._updateWallForNodes(s,this.data.getNode(e.keepId))}needsReplacementWall(t,e,o){const s=t.getOtherNode(e);if(s===o)return!1;const n=W.getCompositeKey(s.id,o.id);return!this.data.walls.has(n)}}class k extends A{onRun(t){const e=this.data.getWall(t.wallId).clone(),o=this.data.getEdgeCountForNode(e.from),s=this.data.getEdgeCountForNode(e.to);this.data._deleteWall(t.wallId);let n="none";return 1===o&&1===s?(n="both",this.data._deleteNode(e.from.id),this.data._deleteNode(e.to.id)):1===o?(n="from",this.data._deleteNode(e.from.id),this.data._updateWallForNodes(e.to)):1===s?(n="to",this.data._deleteNode(e.to.id),this.data._updateWallForNodes(e.from)):(n="none",this.data._updateWallForNodes(e.from,e.to)),{deletedWall:e,deletedNodes:n}}onInvert(t,e){const o=t.deletedWall;let s,n;switch(t.deletedNodes){case"both":s=this.data._createNode({x:o.from.x,z:o.from.z},o.floorIndex,o.from.id),n=this.data._createNode({x:o.to.x,z:o.to.z},o.floorIndex,o.to.id),this.data._createWall(s,n,o.width,o.openings,o.bias);break;case"none":this.data._createWall(o.from,o.to,o.width,o.openings,o.bias),this.data._updateWallForNodes(o.from,o.to);break;case"from":s=this.data._createNode({x:o.from.x,z:o.from.z},o.floorIndex,o.from.id),this.data._createWall(s,o.to,o.width,o.openings,o.bias),this.data._updateWallForNodes(o.to);break;case"to":n=this.data._createNode({x:o.to.x,z:o.to.z},o.floorIndex,o.to.id),this.data._createWall(o.from,n,o.width,o.openings,o.bias),this.data._updateWallForNodes(o.from);break;default:throw new Error(`${t.deletedNodes} is an invalid value`)}}}class L extends A{onRun(t){const e=this.data.getWall(t.fromWallId).clone(),o=e.getDirection().normalize().multiplyScalar(t.along),s=e.from.getVec3().add(o);this.data._deleteWall(t.fromWallId);const n=this.data._createNode({x:s.x,z:s.z},e.floorIndex),a=this.data._createNode(t.to,e.floorIndex),i=this.data._createWall(n,a,t.width,[],.5),r=this.data._createWall(e.from,n,e.width,[],e.bias),d=this.data._createWall(n,e.to,e.width,[],e.bias);return B(e,[r,d],this.data),{deletedWall:e,newTrailingWall:i,newLeftWall:r,newRightWall:d,newNodeToId:a.id}}onInvert(t,e){const{deletedWall:o,newTrailingWall:s,newLeftWall:n,newRightWall:a}=t;this.data._deleteWall(s.id),this.data._deleteWall(n.id),this.data._deleteWall(a.id),this.data._deleteNode(s.from.id),this.data._deleteNode(s.to.id),this.data._createWall(o.from,o.to,o.width,o.openings,o.bias)}merge(t){return!!(t instanceof F&&this._outputCache&&t.inputs.nodeId===this._outputCache.newTrailingWall.to.id)&&(this.inputs.to=t.inputs.newPos,!0)}}class $ extends A{onRun(t){const e=this.data.getWall(t.wallId),o=this.data.getNode(t.nodeId),s={x:o.x,z:o.z},n=e.getDirection().normalize().multiplyScalar(t.along),a=e.from.getVec3().add(n);this.data._deleteWall(e.id),this.data._updateNode(t.nodeId,{x:a.x,z:a.z}),this.data._updateWallForNodes(o);const i=this.data.hasWallBetween(e.from,o)?null:this.data._createWall(e.from,o,e.width,[],e.bias),r=this.data.hasWallBetween(o,e.to)?null:this.data._createWall(o,e.to,e.width,[],e.bias);return B(e,[i,r].filter((t=>!!t)),this.data),{deletedWall:e,newLeftWall:i,newRightWall:r,prevNodePos:s}}onInvert(t,e){const{newLeftWall:o,newRightWall:s,deletedWall:n,prevNodePos:a}=t;o&&this.data._deleteWall(o.id),s&&this.data._deleteWall(s.id),this.data._updateNode(e.nodeId,a),this.data._updateWallForNodes(this.data.getNode(e.nodeId)),this.data._createWall(n.from,n.to,n.width,n.openings,n.bias)}}class K extends A{onRun({wallId:t,props:e}){const o=this.data.getWall(t),s=o.width,n=o.bias;return this.data._setEdgeProps(t,e),{wallId:t,props:{width:s,bias:n}}}onInvert({wallId:t,props:e},o){this.data._setEdgeProps(t,e)}merge(t){return t instanceof K&&t.inputs.wallId===this.inputs.wallId&&(this.inputs.props.width=t.inputs.props.width,this.inputs.props.bias=t.inputs.props.bias,!0)}}class U extends A{onRun(t){const e=this.data.getWall(t.wallId),o=[],s=[],n=[],a={originalFromPos:e.from.getPoint(),originalToPos:e.to.getPoint(),deletedWalls:s,createdWalls:o,originalWallId:t.wallId,createdNodes:n};return t.fromNode&&this.createJoint(e.from,e,s,o,n),t.toNode&&this.createJoint(e.to,e,s,o,n),a}onInvert(t,e){for(const e of t.createdWalls)this.data._deleteWall(e.id);for(const e of t.deletedWalls)this.data._createWall(e.from,e.to,e.width,e.openings,e.bias);for(const e of t.createdNodes)this.data._deleteNode(e.id);const o=this.data.getWall(this.inputs.wallId);this.data._updateNode(o.from.id,t.originalFromPos),this.data._updateNode(o.to.id,t.originalToPos),this.data._updateWallForNodes(o.from,o.to)}merge(t){return t instanceof V&&t.inputs.wallId===this.inputs.wallId&&(this.inputs.fromPos=t.inputs.newFromPos,this.inputs.toPos=t.inputs.newToPos,!0)}createJoint(t,e,o,s,n){const a=this.data._createNode({x:t.x,z:t.z},t.floorIndex),i=this.data.getWallsForNode(t);for(const n of i){const i=n.clone();if(i.id!==e.id){const e=i.getOtherNode(t);o.push(i),this.data._deleteWall(i.id);const n=i.from===e?this.data._createWall(e,a,i.width,[],i.bias):this.data._createWall(a,e,i.width,[],i.bias);B(i,[n],this.data),s.push(n)}}n.push(a);const r=e.from===t?this.data._createWall(a,e.from,e.width,[],e.bias):this.data._createWall(e.to,a,e.width,[],e.bias);s.push(r)}}class G extends A{onRun(t){const e=this.data.getNode(t.nodeId),o=Array.from(this.data.getWallsForNode(e).values());if(2!==o.length)throw new Error("Can only delete nodes with two edges on it");const s=o[0].clone(),n=s.getOtherNode(e),a=o[1].clone(),i=a.getOtherNode(e);this.data._deleteNode(e.id),this.data._deleteWall(s.id),this.data._deleteWall(a.id);const r=this.data.hasWallBetween(n,i)?null:this.data._createWall(n,i,(s.width+a.width)/2,[],(s.bias+a.bias)/2);return r&&(B(s,[r],this.data),B(a,[r],this.data)),{deletedNode:e,deletedWall1:s,deletedWall2:a,createdWall:r}}onInvert(t,e){const{createdWall:o,deletedNode:s,deletedWall1:n,deletedWall2:a}=t;o&&this.data._deleteWall(o.id),this.data._createNode(s.getPoint(),s.floorIndex,s.id),this.data._createWall(n.from,n.to,n.width,n.openings,n.bias),this.data._createWall(a.from,a.to,a.width,a.openings,a.bias)}}function H(t,e){let o,s,n=e[e.length-1],a=0;for(let i=0;i<e.length;++i)o=n,n=e[i],o.y<=t.y&&n.y<=t.y||o.y>t.y&&n.y>t.y||o.x<t.x&&n.x<t.x||(s=(t.y-o.y)*(n.x-o.x)-(t.x-o.x)*(n.y-o.y),n.y<o.y&&(s=-s),a+=s>0?1:0);return a%2==1}function Q(t,e){return t.size===e.size&&[...t].every((t=>e.has(t)))}class j extends A{constructor(){super(...arguments),this.getRelativeAngle=(()=>{const t=new p.Vector2,e=new p.Vector2,o=new p.Vector2,s=(e,o)=>{if(0===e.lengthSq()){const s=this.getNodeNeighbors(o);if(0===s.size)return;const n=Array.from(s.values())[0];e.set(n.x,n.z).sub(t)}};return(n,a,i)=>{if(a===i)return 2*Math.PI;t.set(n.x,n.z),e.set(a.x,a.z).sub(t),s(e,a),o.set(i.x,i.z).sub(t),s(o,i);const r=Math.atan2(e.y,e.x);let d=-(Math.atan2(o.y,o.x)-r);return d<0&&(d+=2*Math.PI),d}})()}onRun(t){const e={createdRooms:[],deletedRooms:[]},o=this.findEnclosedRegions(),s=o.map((t=>new Set(t))),n=new Array;for(const t of this.data.rooms.values())for(let e=0;e<s.length;e++){const o=s[e],a=t.points.reduce(((t,e)=>o.has(e)?t+1:t),0);a>0&&n.push({score:a/t.points.length,oldRoomId:t.id,newRoomIndex:e})}const a=new Set,i=new Array(o.length);n.sort(((t,e)=>{var o,s;return e.score-t.score||((null===(o=this.data.rooms.get(e.oldRoomId))||void 0===o?void 0:o.area)||0)-((null===(s=this.data.rooms.get(t.oldRoomId))||void 0===s?void 0:s.area)||0)}));for(const{oldRoomId:t,newRoomIndex:e}of n)a.has(t)||i[e]||(i[e]=t,a.add(t));for(let t=0;t<o.length;t++)i[t]||(i[t]=(0,b.fV)());for(let t=0;t<o.length;t++){const s=i[t],n=o[t],a=new Set;for(let t=0;t<n.length;t++){const e=n[t],o=n[(t+1)%n.length];this.getWallsForNodes(a,e,o)}const r=new v(s,"",o[t],a),d=this.data.rooms.get(s);d?Q(d.walls,r.walls)||this.data._updateRoom(s,r):(this.data._createRoom(s,o[t],a),e.createdRooms.push(r))}const r=new Set(i);for(const t of this.data.rooms.values())r.has(t.id)||(this.data._deleteRoom(t.id),e.deletedRooms.push(t));return e}onInvert(t,e){if(t.createdRooms)for(const e of t.createdRooms)this.data._deleteRoom(e.id);if(t.deletedRooms)for(const e of t.deletedRooms)this.data._createRoom(e.id,e.points,e.walls)}findEnclosedRegions(){const t=new Array,e=new Set,o=(o,s)=>{const n=`${o.id}/${s.id}`;if(e.has(n))return;const a=[o,s];for(;;){const t=a[a.length-1],e=a[a.length-2],o=this.getNodeNeighbors(t);let s,n=4*Math.PI;for(const a of o){const o=this.getRelativeAngle(t,e,a);o<n&&(n=o,s=a)}if(!s)throw new Error("Expected a neighbor");if(t===a[0]&&s===a[1]){a.pop();break}a.push(s)}z(a)>.4&&t.push(a);for(let t=0;t<a.length;t++){const o=a[t],s=a[(t+1)%a.length],n=`${o.id}/${s.id}`;e.add(n)}};for(const t of this.data.walls.values())o(t.from,t.to),o(t.to,t.from);const s=new Map;for(const e of t)s.set(e,z(e));t.sort(((t,e)=>{const o=t[0].floorIndex-e[0].floorIndex;return 0!==o?o:s.get(t)-s.get(e)}));const n=t.map((t=>t.map((t=>new p.Vector2(t.x,t.z))))),a=new p.Vector2,i=new p.Vector2;for(let e=n.length-1;e>=0;e--){const o=n[e],s=t[e][0].floorIndex;let r=!1;for(let d=0;d<e&&!r;d++){const l=n[d];if(l.length<3||t[d][0].floorIndex!==s)continue;let h=!0;for(let t=0;t<l.length&&h;t++){const e=(t+1)%l.length,o=t,s=(t+2)%l.length;a.copy(l[e]),i.addVectors(l[e],l[o]).add(l[s]).multiplyScalar(1/3),i.sub(a),i.normalize().multiplyScalar(.01),a.add(i),h=!H(a,l)}h||H(a,o)&&(t.splice(e,1),r=!0)}}return t}getNodeNeighbors(t){const e=new Set,o=this.data.getWallsForNode(t);if(!o)throw new Error("Expecting node to wall map to be valid");for(const s of o.values())e.add(s.getOtherNode(t));return e}getWallsForNodes(t,e,o){const s=W.getCompositeKey(e.id,o.id);t.add(this.data.getWall(s))}}class q extends A{onRun(t){const e=this.data.getNode(t.fromId),o=this.data.getNode(t.toId);return{wall:this.data._createWall(e,o,t.width,[],.5).id}}onInvert(t,e){this.data._deleteWall(t.wall)}}class J extends A{onRun(t){const{id:e}=t,o=this.data.getOpening(e),{type:s,relativePos:n,width:a}=o;return this.data._setOpeningDetails(e,t),{id:e,type:s,relativePos:n,width:a}}onInvert(t,e){const{id:o}=t;this.data._setOpeningDetails(o,t)}}class Y extends A{onRun(t){const{openingId:e}=t,o=this.data.getOpening(e);return this.data._deleteWallOpening(e),{deletedOpening:o}}onInvert(t,e){const{id:o,wallId:s,type:n,relativePos:a,width:i}=t.deletedOpening,r=this.data.getWall(s);this.data._createWallOpening(r,n,a,i,o)}}class Z extends A{onRun(t){const{wallId:e,type:o,relativePos:s,width:n}=t,a=this.data.getWall(e);return{openingId:this.data._createWallOpening(a,o,s,n).id}}onInvert(t,e){const{openingId:o}=t;this.data._deleteWallOpening(o)}}class X{constructor(t){this.name="wall-graph",this.version=0,this._nodes=new T,this._walls=new T,this._rooms=new T,this._wallOpenings=new T,this.undoBuffer=new y(this.commit.bind(this)),this._nodeToWallMap=new Map,this._wallToRoomMap=new Map,this._wallsByFloor=new Map,this._observerQueue=[],this._anythingChangeObservers=new Set,this.logger=new P.Z("wall-graph"),this.wallsChanged=!1,this._updateWallForNodes=(()=>{const t=new Set,e=new Set;return(...o)=>{t.clear(),e.clear();const s=o=>{if(!t.has(o)){this._scheduleObserver({observers:this._walls.updatedObservers,param:o});const s=this._wallToRoomMap.get(o);if(s)for(const t of s.values())e.has(t)||(this._scheduleObserver({observers:this._rooms.updatedObservers,param:t}),this.calculateRoomArea(t),e.add(t));for(const t of o.openings)this._scheduleObserver({observers:this._wallOpenings.updatedObservers,param:t});t.add(o)}};for(const t of o){const e=this._nodeToWallMap.get(t);if(null!=e)for(const o of e){s(o);const e=o.getOtherNode(t),n=this._nodeToWallMap.get(e);if(null!=n)for(const t of n)s(t)}}}})(),t&&(this.version=t.version,this.load(t))}load(t){var e;let o=!1;for(const s in t.floors){const n=t.floors[s],a=n.vertices;for(const t in a){const e=a[t];this._createNode({x:e.x,z:-e.y},parseInt(s,10),t)}for(const t in n.edges){const[o,s]=t.split(":"),a=n.edges[t],i=a.thickness,r=this.getNode(o),d=this.getNode(s),l=this._createWall(r,d,i,[],null!==(e=a.bias)&&void 0!==e?e:.5);for(const t in a.openings){const{relativePos:e,type:o,width:s}=a.openings[t];this._createWallOpening(l,o,e,s,t)}}if(n.rooms)for(const t in n.rooms){o=!0;const e=n.rooms[t],s=e.vertices.map((t=>this.getNode(t))),a=new Set;for(let t=0;t<e.vertices.length;t++){const o=e.vertices[t],s=e.vertices[(t+1)%e.vertices.length],n=W.getCompositeKey(o,s);a.add(this.getWall(n))}this._createRoom(t,s,a)}}o||this._recomputeRooms()}get walls(){return this._walls.data}get nodes(){return this._nodes.data}get rooms(){return this._rooms.data}get wallOpenings(){return this._wallOpenings.data}getNode(t){const e=this._nodes.get(t);if(e)return e;throw new Error("WallNode does not exist in WallGraphData")}getWall(t){const e=this._walls.get(t);if(e)return e;throw new Error("Wall does not exist in WallGraphData")}getRoom(t){const e=this._rooms.get(t);if(!e)throw new Error("Room id is invalid!");return e}getOpening(t){const e=this._wallOpenings.get(t);if(!e)throw new Error("Opening id is invalid");return e}getEntity(t){const e=this._walls.get(t)||this._nodes.get(t)||this._rooms.get(t)||this._wallOpenings.get(t);if(!e)throw new Error("No entity for id.");return e}getEdgeCountForNode(t){var e;return(null===(e=this._nodeToWallMap.get(t))||void 0===e?void 0:e.size)||0}getWallsForNode(t){const e=this._nodeToWallMap.get(t);if(e&&e.size>0)return e;throw new Error("WallNode has no associate walls, this should not happen unless inside an action")}getWallsForFloor(t){const e=this._wallsByFloor.get(t);return e&&e.size>0?e:null}getWallNeighbors(t,e){const o=t[e],s=this.getEdgeCountForNode(o);if(1===s)return null;if(2!==s){const s=(()=>{const t=new p.Vector2;return(e,o)=>{const s=o.getOtherNode(e);t.set(s.x-e.x,s.z-e.z).normalize();return t.angle()}})(),n=this._nodeToWallMap.get(o);if(!n||0===n.size)return null;const a=Array.from(n).sort(((t,e)=>s(o,t)-s(o,e))),i=a.indexOf(t);let r=(i+1)%a.length,d=i-1<0?a.length-1:i-1;if("from"===e){const t=d;d=r,r=t}return{left:a[r],right:a[d]}}{const e=this._nodeToWallMap.get(o);if(!e||0===e.size)return null;for(const o of e)if(o.id!==t.id)return{left:o,right:o}}throw new Error("Not finding both neighbors should never happen")}getRoomClassifications(){return["Basement","Bathroom","Bedroom","Closet","Corridor","Dining","Driveway","Facade","Garage","Garden","Yard","Kitchen","Laundry","Living","Lobby","Office","Patio","Pool","Staircase","Unfurnished","Other","Mixed","Unknown"]}hasWallBetween(t,e){const o=W.getCompositeKey(t.id,e.id);return this._walls.has(o)}canDeleteEntity(t){if(null!=t){const e=this.getEntity(t);return e instanceof I?2===this.getEdgeCountForNode(e):e instanceof W||e instanceof E}return!1}undo(){const t=this.undoBuffer.pop();t&&(this.wallsChanged=!1,t.invert(),this.wallsChanged&&this._recomputeRooms(),this.commit())}availableUndos(){return this.undoBuffer.availableUndos()}finalizeHistory(){this.undoBuffer.finalize()}triggerAction(t){try{this.wallsChanged=!1,t.run()}catch(t){return this.logger.error(t),void(this._observerQueue.length=0)}this.undoBuffer.push(t),this.wallsChanged&&(this.triggerAction(new j(this,{})),this.wallsChanged=!1),this.commit()}onNodesChanged(t){return this._nodes.onChanged(t)}onWallsChanged(t){return this._walls.onChanged(t)}onRoomsChanged(t){return this._rooms.onChanged(t)}onOpeningsChanged(t){return this._wallOpenings.onChanged(t)}commit(){const t=this._observerQueue.length;if(this._flushObserverQueue(),t>0)for(const t of this._anythingChangeObservers)t(void 0)}onPropertyChanged(t,e){const o=this["_"+t];if(o instanceof T){const s=o,n=()=>{s.addedObservers.add(e),s.updatedObservers.add(e),s.deletedObservers.add(e)},a=()=>this.removeOnPropertyChanged(t,e);return(0,R.k1)(n,a,!0,t)}throw new Error(`Property: ${t} does not exist on wall-data`)}removeOnPropertyChanged(t,e){const o=this["_"+t];if(!(o instanceof T))throw new Error(`Property: ${t} does not exist on wall-data`);{const t=o;t.addedObservers.delete(e),t.updatedObservers.delete(e),t.deletedObservers.delete(e)}}onChanged(t){if(this._anythingChangeObservers.has(t))throw new Error("This observer function is already observing this Observable, and double subscriptions are not supported.");return(0,R.k1)((()=>this._anythingChangeObservers.add(t)),(()=>this.removeOnChanged(t)),!0)}removeOnChanged(t){this._anythingChangeObservers.delete(t)}addFloatingEdge(t,e,o,s){const n=new M(this,{from:t,to:e,width:o,floorIndex:s});return this.triggerAction(n),n.output}addBridgingEdge(t,e,o){const s=new q(this,{fromId:t,toId:e,width:o});return this.triggerAction(s),s.output}addTrailingEdgeToNode(t,e,o){const s=new S(this,{fromId:t,to:e,width:o});return this.triggerAction(s),s.output}addTrailingEdgeToEdge(t,e,o,s){const n=new L(this,{fromWallId:t,along:e,to:o,width:s});return this.triggerAction(n),n.output}splitEdgeWithNode(t,e,o){const s=new $(this,{wallId:t,nodeId:e,along:o});return this.triggerAction(s),s.output}moveNode(t,e){const o={nodeId:t,newPos:e};this.triggerAction(new F(this,o))}moveWall(t,e,o){const s={wallId:t,newFromPos:e,newToPos:o};this.triggerAction(new V(this,s))}mergeNodes(t,e){const o=new D(this,{keepId:t,mergeId:e});return this.triggerAction(o),o.output}deleteEntity(t){if(this.canDeleteEntity(t)){const e=this.getEntity(t);if(e instanceof I){const e={nodeId:t};this.triggerAction(new G(this,e))}else if(e instanceof W){const e={wallId:t};this.triggerAction(new k(this,e))}else if(e instanceof E){const e={openingId:t};this.triggerAction(new Y(this,e))}}}setEdgeProperties(t,e){const o={wallId:t,props:e};this.triggerAction(new K(this,o))}addWallOpening(t){const e=new Z(this,t);return this.triggerAction(e),e.output.openingId}editWallOpeningDetails(t,e){this.triggerAction(new J(this,Object.assign(Object.assign({},e),{id:t})))}addWallJoint(t,e,o){const s={wallId:t,fromNode:e,toNode:o};this.triggerAction(new U(this,s))}setRoomDetails(t,e){var o,s,n;const a=this.getRoom(t);a.name=null!==(o=e.name)&&void 0!==o?o:a.name,a.roomType=null!==(s=e.roomType)&&void 0!==s?s:a.roomType,a.useRoomTypeAsName=null!==(n=e.useRoomTypeAsName)&&void 0!==n?n:a.useRoomTypeAsName,this._scheduleObserver({observers:this._rooms.updatedObservers,param:a})}_createNode(t,e,o){const s=new I(o||(0,b.fV)(),e,t.x,t.z);return this._nodes.set(s.id,s),this._scheduleObserver({observers:this._nodes.addedObservers,param:s}),s}_updateNode(t,e){const o=this._nodes.get(t);if(!o)throw new Error("Attempted to update WallNode that does not exist");o.x=e.x,o.z=e.z,this._scheduleObserver({observers:this._nodes.updatedObservers,param:o})}_deleteNode(t){const e=this._nodes.get(t);if(!e)throw new Error("Attempted to delete WallNode that does not exist");this._nodes.delete(t),this._scheduleObserver({observers:this._nodes.deletedObservers,param:e})}_createRoom(t,e,o){const s=new v(t,"",e,o);this.rooms.set(t,s);for(const t of o.values()){const e=this._wallToRoomMap.get(t)||new Set;e.add(s),this._wallToRoomMap.set(t,e)}this._scheduleObserver({observers:this._rooms.addedObservers,param:s}),this.calculateRoomArea(s)}_updateRoom(t,e){const o=this._rooms.get(t);if(!o)throw new Error("Attempted to update Room that does not exist");for(const t of o.walls.values()){const e=this._wallToRoomMap.get(t);e&&e.delete(o)}e.name=o.name,e.useRoomTypeAsName=o.useRoomTypeAsName,e.roomType=o.roomType,this.rooms.set(t,e);for(const t of e.walls.values()){const o=this._wallToRoomMap.get(t)||new Set;o.add(e),this._wallToRoomMap.set(t,o)}this._scheduleObserver({observers:this._rooms.updatedObservers,param:e}),this.calculateRoomArea(e)}_deleteRoom(t){const e=this._rooms.get(t);if(!e)throw new Error("Attempted to delete Room that does not exist");this._rooms.delete(e.id);for(const t of e.walls.values()){const o=this._wallToRoomMap.get(t);null==o||o.delete(e)}this._scheduleObserver({observers:this._rooms.deletedObservers,param:e})}_createWall(t,e,o,s,n){if(t.id===e.id)throw new Error("Cannot create wall where the from node is the same as the to node.");if(t.floorIndex!==e.floorIndex)throw new Error("Cannot create a wall between nodes on different floors.");const a=W.getCompositeKey(t.id,e.id);if(this._walls.has(a))throw new Error(`Wall already exists between ${t.id}:${e.id}`);const i=this.getNode(t.id),r=this.getNode(e.id),d=new W(a,i,r,o,n);this._walls.set(d.id,d),this._addToWallDicts(d),this._scheduleObserver({observers:this._walls.addedObservers,param:d});for(const t of s){const{type:e,relativePos:o,width:s,id:n}=t;this._createWallOpening(d,e,o,s,n)}return this.wallsChanged=!0,d}_deleteWall(t){const e=this.getWall(t);for(const t of e.openings.slice())this._deleteWallOpening(t.id);this._walls.delete(t),this._removeFromWallDicts(e),this._scheduleObserver({observers:this._walls.deletedObservers,param:e}),this.wallsChanged=!0}_setEdgeProps(t,e){const{width:o,bias:s}=e,n=this.getWall(t);void 0!==o&&(n.width=o),void 0!==s&&(n.bias=s),this._updateWallForNodes(n.from,n.to)}_createWallOpening(t,e,o,s,n){const a=new E(n||(0,b.fV)(),t.id,e,o,s);return this._wallOpenings.set(a.id,a),t.openings.push(a),this._scheduleObserver({observers:this._wallOpenings.addedObservers,param:a}),a}_setOpeningDetails(t,e){var o,s,n;const a=this.getOpening(t);a.type=null!==(o=e.type)&&void 0!==o?o:a.type,a.relativePos=null!==(s=e.relativePos)&&void 0!==s?s:a.relativePos,a.width=null!==(n=e.width)&&void 0!==n?n:a.width,this._scheduleObserver({observers:this._wallOpenings.updatedObservers,param:a})}_deleteWallOpening(t){const e=this.getOpening(t),o=this.getWall(e.wallId),s=o.openings.findIndex((e=>e.id===t));if(-1===s)throw new Error("Expected opening to exist in wall array!");o.openings.splice(s,1),this._wallOpenings.delete(t),this._scheduleObserver({observers:this._wallOpenings.deletedObservers,param:e})}_setRoomDetails(t,e){const o=this.getRoom(t);o.name=e,this._scheduleObserver({observers:this._rooms.updatedObservers,param:o})}_addToWallDicts(t){const e=(e,o)=>{let s=o.get(e);null!=s?s.add(t):(s=new Set,s.add(t),o.set(e,s))};e(t.from,this._nodeToWallMap),e(t.to,this._nodeToWallMap),e(t.floorIndex,this._wallsByFloor)}_removeFromWallDicts(t){const e=(e,o)=>{const s=o.get(e);null!=s&&(s.delete(t),0===s.size&&o.delete(e))};e(t.from,this._nodeToWallMap),e(t.to,this._nodeToWallMap),e(t.floorIndex,this._wallsByFloor),this._wallToRoomMap.delete(t)}_scheduleObserver(t){this._observerQueue.push(t)}_flushObserverQueue(){for(const t of this._observerQueue)for(const e of t.observers){const o=t.param;e(o,o.id)}this._observerQueue.length=0}getSnapshot(){const t={version:this.version,floors:{}},e=e=>{t.floors[`${e}`]||(t.floors[`${e}`]={edges:{},vertices:{},rooms:{}})};for(const[o,s]of this._nodes.data){e(s.floorIndex);t.floors[`${s.floorIndex}`].vertices[s.id]=s.getSnapshot()}for(const[o,s]of this._walls.data){e(s.floorIndex);t.floors[`${s.floorIndex}`].edges[s.id]=s.getSnapshot()}for(const[o,s]of this._rooms.data){e(s.floorIndex);t.floors[`${s.floorIndex}`].rooms[s.id]=s.getSnapshot()}return t}_recomputeRooms(){new j(this,{}).run()}calculateRoomArea(t){let e=0;const o=(e,o,s)=>{let n=0;s.set(.5*e.width,0);const a=this.getWallNeighbors(e,o);if(a){const i=t.walls.has(a.left),r=i?a.left:a.right;if(t.walls.has(r)){i&&s.multiplyScalar(-1);const t=r.getOtherNode(e[o]);n=Math.atan2(-(t.z-e.from.z),-(t.x-e.from.x))}}s.rotateAround(new p.Vector2,.5*n)},s=z(t.points),n=new p.Vector3;for(const a of t.walls.values()){const i=new p.Vector2;o(a,"from",i);const r=new p.Vector2;o(a,"to",r),r.add(new p.Vector2(0,a.length));let d=.5;a.getBiasAdjustmentVec(n);const l=t.points.map((t=>a.from===t||a.to===t?[t.x+n.x,t.z+n.z]:[t.x,t.z]));l.push(l[0]);d=C(l)<s?a.bias>.5?a.bias:1-a.bias:a.bias<.5?a.bias:1-a.bias;const h=a.width*d;e+=.5*(a.length+r.sub(i).length())*h}t.area=s-e}}class tt extends s.Y{constructor(){super(...arguments),this.name="roombounds"}async init(t,e){this.data=new X,e.market.register(this,X,this.data),async function(t,e){const[o,s]=await Promise.all([t.market.waitForData(r.R),t.market.waitForData(u.i)]),a=(n,a,i,r=[])=>{const d=[];for(const a of e.rooms.values())if(n(a.name)||n(a.roomType)){const e=s.getFloorAtIndex(a.floorIndex);if(!e)throw new Error("Unable to find floor for room while generating search results.");d.push(new g(t.commandBinder,o,a,e.id))}return d.sort(((t,e)=>t.title.localeCompare(e.title)))},d=t=>{},c=t=>new n.V(e.onChanged(t)),p={renew:()=>{t.commandBinder.issueCommandWhenBound(new h.c6({id:i.SF.MODELROOM,groupPhraseKey:l.Z.TOOLS.ROOMPLAN,getSimpleMatches:a,registerChangeObserver:c,onSearchActivatedChanged:d,groupOrder:40,groupIcon:"icon-edit-floorplan"}))},cancel:()=>{t.commandBinder.issueCommandWhenBound(new h.Pe(i.SF.MODELROOM))}};return p.renew(),p}(e,this.data).then((t=>this.bindings.push(t)))}dispose(t){super.dispose(t)}}const et=tt},56163:(t,e,o)=>{o.d(e,{K:()=>r});var s=o(52528),n=o(71166),a=o(63319);const i=new s.v({});class r{constructor(t,e,o){this.commandBinder=t,this.layersData=e,this.dataTypeGroup=o,this.textParser=i,this.enabled=!0,this.bindings=[]}getGroupingId(t){switch(t){case a.HH.TYPE:return this.getTypeId();case a.HH.FLOOR:return this.getFloorId();case a.HH.LAYER:return this.getLayerGroupId();case a.HH.DATE:return this.dateBucket}}getFloorId(){return this.floorId}getDateBucket(){return this.dateBucket}getTypeId(){return this.typeId}supportsBatchDelete(){return!1}supportsLayeredCopyMove(){return!1}getLayerGroupId(){var t,e;const o=null===(t=this.layersData)||void 0===t?void 0:t.getBaseLayerId(),s=null===(e=this.layersData)||void 0===e?void 0:e.getViewLayerId();return this.layerId&&s&&this.layerId===o?s:this.layerId}isLayerVisible(){return!this.layersData||!this.layerId||this.layersData.layerVisible(this.layerId)}onSelect(t,e,o){this.commandBinder.issueCommand(new n.IL(this.id,this.typeId))}registerBindings(){}cancelBindings(){this.bindings.forEach((t=>t.cancel()))}}}}]);